- name: "Basic pipeline: extract and format as pretty JSON"
  options: { format: 'json', pretty: true }
  input: "File is src/index.ts and another is ./README.md"
  files:
    "src/index.ts": ""
    "./README.md": ""
  expected: |
    [
      "src/index.ts",
      "./README.md"
    ]

- name: "Pipeline with verification, filtering out non-existent paths"
  options: { format: 'list', verify: true }
  input: "Existing file: file1.txt. Missing file: missing.txt. Existing subdir file: dir/file2.log"
  files:
    'file1.txt': 'content'
    'dir/file2.log': 'log content'
  expected: |
    file1.txt
    dir/file2.log

- name: "Pipeline with absolute path conversion"
  options: { absolute: true, format: 'json', pretty: false, verify: false } # verification disabled
  input: "Relative path: src/main.js and ./index.html"
  files: {}
  expected: '["{{CWD}}/src/main.js","{{CWD}}/index.html"]'

- name: "Pipeline with verification and absolute path conversion"
  options: { absolute: true, format: 'yaml', verify: true }
  input: "Real: src/app.ts. Fake: src/fake.ts"
  files:
    'src/app.ts': 'export default {}'
  expected: |
    - {{CWD}}/src/app.ts

- name: "Pipeline with different format (yaml) and no unique"
  options: { format: 'yaml', unique: false, verify: false }
  input: "path: a.txt, again: a.txt"
  files: {}
  expected: |
    - a.txt
    - a.txt

- name: "Pipeline should produce empty output for no matches"
  options: { format: 'json' }
  input: "Just some regular text without any paths."
  files: {}
  expected: "[]"

- name: "Pipeline with complex paths and query strings"
  options: { format: 'list', verify: false }
  input: "Path1: /a/b.css?v=1 Path2: src/d.ts#foo Path3: user@domain.com"
  files: {}
  expected: |
    /a/b.css
    src/d.ts

- name: "Pipeline with quoted path with spaces and verification"
  options: { format: 'list', verify: true }
  input: 'Log: "real dir/real file.txt" and "fake dir/fake file.txt"'
  files:
    'real dir/real file.txt': 'content'
  expected: |
    real dir/real file.txt