uuid: 4f44c66e-214e-4f7f-afbd-e970b13cf14a
projectId: pathfish
createdAt: '2025-09-28T14:19:32.989Z'
gitCommitMsg: >-
  feat(core): Enhance path extraction robustness and test coverage

  Improves the core path extraction engine with several key enhancements:

  - Updates the main regex to be more precise, avoiding false positives from
  email addresses (e.g., `domain.com`) and URLs by using negative lookbehinds. -
  Adds support for detecting common extension-less filenames like `Dockerfile`
  and `Makefile`. - Expands the path cleanup logic to strip a wider variety of
  surrounding punctuation, such as brackets, quotes, and parentheses. - Adds new
  unit test fixtures to validate these improvements, covering special
  characters, surrounding punctuation, and domain name avoidance.
promptSummary: >-
  The user requested more comprehensive test cases and coverage, especially for
  complex file paths and domains. I improved the path extraction regex and
  cleanup logic in `src/core.ts` and added corresponding test cases to
  `test/unit/core.fixtures.yaml`.
reasoning:
  - >-
    Based on your request to add more comprehensive test cases and improve
    coverage, especially for complex fixtures like domains and file paths, I've
    identified several areas for enhancement in the core path extraction logic.
  - 'My plan is as follows:'
  - >-
    1.  **Refine Path Extraction Regex**: I will update the regular expression
    in `src/core.ts` to be more robust. This includes:
  - >-
    *   Better handling of standalone filenames to prevent conflicts with
    relative paths.
  - >-
    *   Adding support for common filenames that lack extensions (e.g.,
    `Dockerfile`).
  - >-
    *   Introducing negative lookbehinds to intelligently ignore domain names
    found in email addresses and URLs, which is a common source of false
    positives.
  - '*   Allowing for digits in file extensions (e.g., `file.v2.js`).'
  - >-
    2.  **Improve Path Cleanup**: I'll enhance the cleanup logic in
    `src/core.ts` to strip a wider range of surrounding punctuation (like `()`,
    `[]`, `<>`, `"`) from matched paths, making the extraction more reliable
    when paths are embedded in prose.
  - >-
    3.  **Expand Test Fixtures**: I will add several new test cases to
    `test/unit/core.fixtures.yaml` to validate these improvements, covering:
  - '*   Paths with special characters and surrounding punctuation.'
  - '*   Detection of common extension-less files.'
  - >-
    *   Correctly ignoring domains in emails and URLs while still finding valid
    paths.
  - >-
    These changes will significantly increase the accuracy and robustness of the
    path extraction engine.
  - '### 1. Enhance core path extraction logic'
  - >-
    I'll start by updating `src/core.ts` with the improved regular expression
    and cleanup logic. The new regex will be more precise in identifying valid
    file paths while avoiding common non-path patterns like domains. The cleanup
    step will handle a wider variety of surrounding characters.
  - '### 2. Add comprehensive test cases'
  - >-
    Next, I'll add the new test cases to `test/unit/core.fixtures.yaml` to
    verify the enhanced logic and cover the new edge cases. These tests will
    ensure the changes work as expected and prevent future regressions.
  - >-
    These changes improve the core functionality of `pathfish` by making its
    path detection smarter and more accurate, directly addressing your request
    for more comprehensive coverage of complex cases.
operations:
  - type: write
    path: src/core.ts
    content: >+
      --- src/core.ts

      +++ src/core.ts

      @@ -47,21 +47,26 @@
       // 3. Relative paths with separators (src/file.ts, ./dist, ../parent)
       // 4. Standalone filenames with extensions (README.md, package.json)
       const PATH_REGEX = new RegExp(
         [
           // Windows absolute paths: C:\path\to\file (must come first to avoid partial matches)
           /[a-zA-Z]:[\\\/][^\s\n]+(?:[\\\/][^\s\n]+)*/.source,
       
           // Unix absolute paths: /path/to/file
           /\/[^\s\n]+(?:[\\\/][^\s\n]+)*/.source,
       
           // Relative paths with separators: ./file, ../file, src/file
           /(?:\.[\\/]|[^\s\n]+[\\/])[^\s\n]+(?:[\\\/][^\s\n]+)*/.source,
       
      -    // Standalone filenames with extensions: file.txt, README.md

      -    /\b[^\s\n]+\.[a-zA-Z]+\b/.source,

      +    // Standalone filenames with extensions: file.txt, README.md.

      +    // It avoids matching email domains and parts of URLs by using a
      negative

      +    // lookbehind for '@' and '//'. It also prevents slashes in the
      filename

      +    // part to avoid overlapping with the relative path regex.

      +    /(?<!@|\/\/)\b[^\s\n\\/]+\.[a-zA-Z0-9]+\b/.source,

      +

      +    // Common filenames without extensions

      +    /\b(?:Dockerfile|Makefile|Jenkinsfile|Vagrantfile)\b/.source,
         ].join('|'),
         'g',
       );
       
      @@ -79,9 +84,9 @@
           const matches = Array.from(text.matchAll(PATH_REGEX), m => m[0]);
       
           // 2. Clean up matches: remove trailing line/col numbers and common punctuation.
           const cleanedPaths = matches.map(p =>
             p.replace(/(?::\d+)+$/, '') // a/b/c:10:5 -> a/b/c
      -       .replace(/[.,;]$/, '')     // a/b/c, -> a/b/c

      -       .replace(/\\\\/g, '\\')    // Normalize double backslashes to
      single

      +       .replace(/^[ "'(<]+|[ .,;"')>]+$/g, '') // strip surrounding
      punctuation

      +       .replace(/\\\\/g, '\\'), // Normalize double backslashes to single
           );
       
           // 3. Filter out commonly ignored paths (e.g., node_modules).

    patchStrategy: standard-diff
  - type: write
    path: test/unit/core.fixtures.yaml
    content: >+
      --- test/unit/core.fixtures.yaml

      +++ test/unit/core.fixtures.yaml

      @@ -82,3 +82,35 @@
           But this is fine: my-package.json
         expected:
           - "my-package.json"
      +

      +- name: "Paths with special characters and surrounding punctuation"

      +  options: {}

      +  input: |

      +    Paths can be tricky: (src/components/Button (new).tsx),

      +    <[dist/app-v2.js]>, or even "quoted/path.css".

      +    A path with a number in extension: file.v2.js

      +  expected:

      +    - "src/components/Button (new).tsx"

      +    - "dist/app-v2.js"

      +    - "quoted/path.css"

      +    - "file.v2.js"

      +

      +- name: "Should extract common files without extensions"

      +  options: {}

      +  input: "Check the Dockerfile and also the Makefile for build
      instructions."

      +  expected:

      +    - "Dockerfile"

      +    - "Makefile"

      +

      +- name: "Should avoid matching domains from emails and URLs"

      +  options: {}

      +  input: |

      +    Contact me at user@domain.com.

      +    Check the website http://example.org/index.html and also
      https://another.com.

      +    A file share: //server/file.txt

      +    But this should be found: a/b/c.com

      +  expected:

      +    - "/index.html"

      +    - "a/b/c.com"

      +    - "/server/file.txt"

    patchStrategy: standard-diff
snapshot:
  src/core.ts: >-
    import path from 'node:path';


    /**
     * Options for path extraction.
     */
    export type Options = {
      /**
       * Convert all found paths to absolute paths.
       * @default false
       */
      absolute?: boolean;
      /**
       * The base directory for resolving relative paths.
       * @default process.cwd()
       */
      cwd?: string;
      /**
       * Ensure the returned list contains only unique paths.
       * @default true
       */
      unique?: boolean;
    };


    const DEFAULT_IGNORE_DIRS = ['node_modules', '.git', 'dist', 'build'];

    const DEFAULT_IGNORE_FILES = ['package-lock.json', 'bun.lockb'];


    /**
     * Checks if a given path matches any of the default ignore patterns.
     * @param p The path string to check.
     * @returns True if the path should be ignored, false otherwise.
     */
    const isIgnored = (p: string): boolean => {
      // Check against ignored directory patterns. This is a simple check; we see if
      // any path segment is an exact match for a directory we want to ignore.
      // This avoids accidentally filtering 'distribution/file.js'.
      const segments = p.split(/[\\\/]/);
      if (segments.some(segment => DEFAULT_IGNORE_DIRS.includes(segment))) {
        return true;
      }

      // Check against ignored file patterns by looking at the basename.
      const basename = path.basename(p);
      return DEFAULT_IGNORE_FILES.includes(basename);
    };


    // This regex finds file paths, including optional line/column numbers. It's

    // designed to be comprehensive, supporting Windows, Unix, absolute, and

    // relative paths. The regex is structured to match complete paths:

    // 1. Windows absolute paths (C:\path\to\file)

    // 2. Unix absolute paths (/path/to/file)

    // 3. Relative paths with separators (src/file.ts, ./dist, ../parent)

    // 4. Standalone filenames with extensions (README.md, package.json)

    const PATH_REGEX = new RegExp(
      [
        // Windows absolute paths: C:\path\to\file (must come first to avoid partial matches)
        /[a-zA-Z]:[\\\/][^\s\n]+(?:[\\\/][^\s\n]+)*/.source,

        // Unix absolute paths: /path/to/file
        /\/[^\s\n]+(?:[\\\/][^\s\n]+)*/.source,

        // Relative paths with separators: ./file, ../file, src/file
        /(?:\.[\\/]|[^\s\n]+[\\/])[^\s\n]+(?:[\\\/][^\s\n]+)*/.source,

        // Standalone filenames with extensions: file.txt, README.md
        /\b[^\s\n]+\.[a-zA-Z]+\b/.source,
      ].join('|'),
      'g',
    );


    /**
     * A higher-order function that creates a path extraction pipeline.
     * This functional approach makes the process clear, configurable, and extensible.
     * @param opts Configuration options for the pipeline.
     * @returns A function that takes text and returns an array of paths.
     */
    const createPathExtractionPipeline = (opts: Options = {}) => {
      const { absolute = false, cwd = process.cwd(), unique = true } = opts;

      return (text: string): string[] => {
        // 1. Find all potential paths using the regex.
        const matches = Array.from(text.matchAll(PATH_REGEX), m => m[0]);

        // 2. Clean up matches: remove trailing line/col numbers and common punctuation.
        const cleanedPaths = matches.map(p =>
          p.replace(/(?::\d+)+$/, '') // a/b/c:10:5 -> a/b/c
           .replace(/[.,;]$/, '')     // a/b/c, -> a/b/c
           .replace(/\\\\/g, '\\')    // Normalize double backslashes to single
        );

        // 3. Filter out commonly ignored paths (e.g., node_modules).
        const filteredPaths = cleanedPaths.filter(p => !isIgnored(p));

        // 4. (Optional) Filter for unique paths.
        const uniquePaths = unique ? Array.from(new Set(filteredPaths)) : filteredPaths;

        // 5. (Optional) Resolve paths to be absolute.
        const resolvedPaths = absolute
          ? uniquePaths.map(p => path.resolve(cwd, p))
          : uniquePaths;

        return resolvedPaths;
      };
    };


    /**
     * Extracts potential file paths from a blob of text using a configurable pipeline.
     * @param text The text to search within.
     * @param opts Configuration options for extraction.
     * @returns An array of found file paths.
     */
    export function extractPaths(text: string, opts: Options = {}): string[] {
      const extractor = createPathExtractionPipeline(opts);
      return extractor(text);
    }


    /**
     * Filters a list of paths, keeping only the ones that exist on disk.
     * @param paths An array of file paths to check.
     * @param cwd The working directory to resolve relative paths against.
     * @returns A promise that resolves to an array of existing file paths.
     */
    export async function verifyPaths(paths: string[], cwd: string =
    process.cwd()): Promise<string[]> {
      // Concurrently check for the existence of each file.
      const checks = paths.map(p => {
        const absolutePath = path.isAbsolute(p) ? p : path.resolve(cwd, p);
        return Bun.file(absolutePath).exists();
      });
      const existenceChecks = await Promise.all(checks);

      // Filter the original paths array based on the results of the existence checks.
      const existingPaths = paths.filter((_, i) => existenceChecks[i]);

      return existingPaths;
    }
  test/unit/core.fixtures.yaml: |-
    - name: "Basic path extraction"
      options: {}
      input: |
        Here are some files: src/core.ts and ./README.md
        Also, a log file /var/log/syslog
      expected:
        - "src/core.ts"
        - "./README.md"
        - "/var/log/syslog"

    - name: "Windows path extraction"
      options: {}
      input: |
        Error in C:\\Users\\Test\\project\\src\\file.js
        Check the config at .\\config\\settings.json
      expected:
        - "C:\\Users\\Test\\project\\src\\file.js"
        - ".\\config\\settings.json"

    - name: "Path extraction with line and column numbers"
      options: {}
      input: |
        src/components/Button.tsx:5:10 - error
        dist/bundle.js:1:12345
        /app/main.py:42
      expected:
        - "src/components/Button.tsx"
        - "/app/main.py"

    - name: "Standalone filenames with extensions"
      options: {}
      input: |
        The project uses bun.lockb and has a README.md.
        But this is: package.json
      expected:
        - "README.md"
        - "package.json"

    - name: "Unique paths option (default)"
      options: { unique: true }
      input: "See src/core.ts and again src/core.ts"
      expected: ["src/core.ts"]

    - name: "Non-unique paths option"
      options: { unique: false }
      input: "See src/core.ts and again src/core.ts"
      expected: ["src/core.ts", "src/core.ts"]

    - name: "Absolute paths option"
      options: { absolute: true, cwd: "/home/user/project" }
      input: |
        Relative path: src/index.ts
        Dot-slash path: ./dist/main.js
        Absolute path is unchanged: /etc/hosts
      expected:
        - "/home/user/project/src/index.ts"
        - "/etc/hosts"

    - name: "Empty input"
      options: {}
      input: "No paths here."
      expected: []

    - name: "Should ignore common transient/generated directories"
      options: {}
      input: |
        Path in node_modules/package/file.js
        Path in .git/hooks/pre-commit
        Path in dist/bundle.js
        Path in project/build/output.css
        A file called distribution/file.js should not be ignored.
      expected:
        - "distribution/file.js"

    - name: "Should ignore common lockfiles"
      options: {}
      input: |
        This project uses bun.lockb and package-lock.json.
        But this is fine: my-package.json
      expected:
        - "my-package.json"
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: '2025-09-28T14:24:29.515Z'
status: committed
id: 22
