uuid: f74df160-b6f7-4144-8da9-a20c35478051
projectId: pathfish
createdAt: '2025-09-30T01:59:32.240Z'
gitCommitMsg: >-
  fix(build): resolve typescript compilation errors

  This commit addresses several TypeScript errors that were preventing the
  project from compiling successfully.

  1.  A runtime type error in `src/core.ts` has been fixed. Due to the
  `noUncheckedIndexedAccess` compiler option, a character access could be
  `undefined`. A check has been added to ensure the value is a string before
  it's used in a regular expression.

  2.  Unit and integration tests have been updated to import modules directly
  from the `src` directory instead of the compiled `dist` directory. This allows
  the TypeScript compiler to find the original type definitions and resolves
  several "module has no exported member" errors. This change also makes the
  test suite more robust by testing against the source code directly.
promptSummary: >-
  The user provided a list of TypeScript compilation errors. The first was a
  type error in `src/core.ts` due to `noUncheckedIndexedAccess`. The others were
  due to tests importing types from the compiled `dist` directory, which lacks
  type information.
reasoning:
  - I've identified the cause of the compilation errors and will apply fixes.
  - '### Reasoning'
  - >-
    1.  **Type Error in `src/core.ts`**: The error `Argument of type 'string |
    undefined' is not assignable to parameter of type 'string'` is caused by the
    `noUncheckedIndexedAccess` TypeScript option being enabled. When accessing
    `text[match.index - 1]`, TypeScript correctly infers that the result could
    be `undefined`. The fix is to add a truthiness check for the `charBefore`
    variable before passing it to the regex `test()` method. This ensures we are
    only testing a valid string.
  - >-
    2.  **Type Import Errors in Tests**: The remaining four errors stem from the
    unit and integration tests trying to import types from the compiled
    JavaScript files in the `dist/` directory (e.g., `from
    '../../dist/core.js'`). The build process, handled by `tsup`, generates
    JavaScript but doesn't embed the TypeScript types in a way that `tsc` can
    understand without corresponding `.d.ts` declaration files. While
    configuring the build to emit these files is one solution, a more robust and
    common practice for unit/integration testing is to have the tests import
    directly from the TypeScript source files in `src/`. Bun's test runner can
    transpile and execute TypeScript on the fly. This change makes the tests
    independent of the build output and allows the TypeScript compiler (`tsc
    --noEmit`) to resolve the types correctly by looking at the source.
  - I will now apply these two fixes.
  - '### Code Changes'
  - First, I'll fix the TypeScript error in `src/core.ts`.
  - >-
    Next, I'll update the test files to import from the `src` directory instead
    of `dist`.
operations:
  - type: write
    path: src/core.ts
    content: |+
      --- src/core.ts
      +++ src/core.ts
      @@ -211,7 +211,7 @@
             while ((match = basenameRegex.exec(text)) !== null) {
               if (match.index > 0) {
                 const charBefore = text[match.index - 1];
                 // Avoid matching a basename that is part of a larger filename
                 // e.g. matching 'types.ts' inside 'domain.types.ts'
      -          if (/[\w.-]/.test(charBefore)) {
      +          if (charBefore && /[\w.-]/.test(charBefore)) {
                   continue;
                 }
               }

    patchStrategy: standard-diff
  - type: write
    path: test/integration/engine.test.ts
    content: |
      <<<<<<< SEARCH
      import { runPipeline, type PipelineOptions } from '../../dist/engine.js';
      =======
      import { runPipeline, type PipelineOptions } from '../../src/engine';
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: test/unit/core.test.ts
    content: >
      <<<<<<< SEARCH

      import { extractPaths, verifyPaths, type Options, type Strategy } from
      '../../dist/core.js';

      =======

      import { extractPaths, verifyPaths, type Options, type Strategy } from
      '../../src/core';

      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: test/unit/utils.test.ts
    content: |
      <<<<<<< SEARCH
      import { createFormatter, type Format } from '../../dist/utils.js';
      =======
      import { createFormatter, type Format } from '../../src/utils';
      >>>>>>> REPLACE
    patchStrategy: search-replace
snapshot:
  test/unit/utils.test.ts: |
    import { describe, it, expect } from 'bun:test';
    import { createFormatter, type Format } from '../../dist/utils.js';
    import { loadYamlFixture } from '../test.utils';

    type FormatterTestCase = {
      name: string;
      format: Format;
      pretty: boolean;
      input: string[];
      expected: string;
    };

    type FormatterFixture = (
      | FormatterTestCase
      | { name: string; cases: FormatterTestCase[] }
    )[];

    describe('createFormatter', async () => {
      it('should throw an error for an unknown format', () => {
        // This is a type-level check, but we test the runtime guard
        const badFormat = 'xml' as unknown as Format;
        expect(() => createFormatter(badFormat, true)).toThrow(
          'Unknown format: xml',
        );
      });

      const fixtures = await loadYamlFixture<FormatterFixture>('unit/utils.fixtures.yaml');

      for (const fixture of fixtures) {
        if ('cases' in fixture) {
          describe(fixture.name, () => {
            for (const testCase of fixture.cases) {
              it(`should format as ${testCase.format}`, () => {
                const format = createFormatter(testCase.format, testCase.pretty);
                const result = format(testCase.input);
                expect(result.trim()).toEqual(testCase.expected.trim());
              });
            }
          });
        } else {
          it(fixture.name, () => {
            const format = createFormatter(fixture.format, fixture.pretty);
            const result = format(fixture.input);
            // Use trim to handle potential trailing newlines from YAML multiline strings
            expect(result.trim()).toEqual(fixture.expected.trim());
          });
        }
      }
    });
  src/core.ts: >-
    import path from 'node:path';

    import { promises as fs } from 'node:fs';


    export type Strategy = 'regex' | 'fuzzy' | 'both';


    /**
     * Options for path extraction.
     */
    export type Options = {
      /**
       * Convert all found paths to absolute paths.
       * @default false
       */
      absolute?: boolean;
      /**
       * The base directory for resolving relative paths.
       * @default process.cwd()
       */
      cwd?: string;
      /**
       * Ensure the returned list contains only unique paths.
       * @default true
       */
      unique?: boolean;
      /**
       * The path extraction strategy to use.
       * @default 'fuzzy'
       */
      strategy?: Strategy;
    };


    const DEFAULT_IGNORE_DIRS = ['node_modules', '.git', 'dist', 'build'];

    const DEFAULT_IGNORE_FILES = ['package-lock.json', 'bun.lockb'];


    /**
     * Checks if a given path matches any of the default ignore patterns.
     * @param p The path string to check.
     * @returns True if the path should be ignored, false otherwise.
     */
    const isIgnored = (p: string): boolean => {
      // Check against ignored directory patterns. This is a simple check; we see if
      // any path segment is an exact match for a directory we want to ignore.
      // This avoids accidentally filtering 'distribution/file.js'.
      const segments = p.split(/[\\\/]/);
      if (segments.some(segment => DEFAULT_IGNORE_DIRS.includes(segment))) {
        return true;
      }

      // Check against ignored file patterns by looking at the basename.
      const basename = path.basename(p);
      return DEFAULT_IGNORE_FILES.includes(basename);
    };


    // This regex finds file paths, including optional line/column numbers. It's

    // designed to be comprehensive, supporting Windows, Unix, absolute, and

    // relative paths. The regex is structured to match complete paths:

    // 1. Windows absolute paths (C:\path\to\file)

    // 2. Unix absolute paths (/path/to/file)

    // 3. Relative paths with separators (src/file.ts, ./dist, ../parent)

    // 4. Standalone filenames with extensions (README.md, package.json)

    const PATH_REGEX = new RegExp(
      [
        // Quoted paths with spaces (must come first to allow spaces)
        /(?:"[^"]*[\\\/][^"]*"|'[^']*[\\\/][^']*')/.source,

        // Parenthesized paths with spaces: (src/components/Button (new).tsx)
        /\([^,)]*[\\\/][^,)]*\([^)]*\)[^,)]*\.[a-zA-Z0-9]+\)/.source,

        // Windows UNC paths: \\server\share\file (must come before absolute)
        /[\\\/]{2}[^\s\n]+[\\\/][^\s\n]+(?:[\\\/][^\s\n]+)*/.source,

        // Windows absolute paths: C:\path\to\file (must come first to avoid partial matches)
        /[a-zA-Z]:[\\\/][^\s\n]+(?:[\\\/][^\s\n]+)*/.source,

        // Unix absolute paths: /path/to/file
        /\/[^\s\n"']+(?:[\\\/][^\s\n"']+)*/.source,

        // Relative paths with separators: ./file, ../file, src/file
        /(?:\.[\\/]|[^\s\n"']+[\\/])[^\s\n"']+(?:[\\\/][^\s\n"']+)*/.source,

        // Same as above, but uses a lookbehind to allow leading whitespace (for indented paths in logs)
        /(?<=\s)(?:\.[\\/]|[^\s\n"']+[\\/])[^\s\n"']+(?:[\\\/][^\s\n"']+)*/.source,

        // Standalone filenames with extensions: file.txt, README.md, my.component.test.js.
        // Use negative lookbehind to avoid email domains and URL contexts
        // Supports multi-dot filenames like my.component.test.js
        /(?<!@|https?:\/\/[^\s]*)\b[a-zA-Z0-9_.-]+\.[a-zA-Z0-9]{1,}\b(?![\\\/])(?!\s*@)(?![^"]*")/.source,

        // Common filenames without extensions
        /\b(?:Dockerfile|Makefile|Jenkinsfile|Vagrantfile)\b/.source,
      ].join('|'),
      'g',
    );


    async function walk(dir: string): Promise<string[]> {
      let entries: import('node:fs').Dirent[];
      try {
        entries = await fs.readdir(dir, { withFileTypes: true });
      } catch {
        // Ignore errors from directories that cannot be read
        return [];
      }

      const promises = entries.map(async (entry) => {
        const fullPath = path.join(dir, entry.name);
        if (entry.isDirectory()) {
          return walk(fullPath);
        }
        return [fullPath];
      });

      const results = await Promise.all(promises);
      return results.flat();
    }


    /**
     * Extracts paths using a fuzzy strategy by looking for file basenames in text.
     * @param text The text to search within.
     * @param cwd The working directory to scan for files.
     * @returns A promise resolving to an array of found relative paths.
     */
    async function extractPathsWithFuzzy(text: string, cwd: string):
    Promise<string[]> {
      const allAbsolutePaths = await walk(cwd);
      const foundPaths = new Set<string>();
      const normalizedText = text.replace(/\\/g, '/').replace(/['"`]/g, '');

      const basenameToPaths = new Map<string, string[]>();
      const allRelativePaths: string[] = [];

      // Pre-process all paths once to build up our data structures
      for (const absolutePath of allAbsolutePaths) {
        const relativePath = path.relative(cwd, absolutePath);
        if (isIgnored(relativePath)) continue;

        allRelativePaths.push(relativePath);

        const basename = path.basename(relativePath);
        if (!basenameToPaths.has(basename)) basenameToPaths.set(basename, []);
        basenameToPaths.get(basename)!.push(relativePath);
      }

      // Pass 1: Prioritize full, unambiguous path matches found in the text.
      for (const relativePath of allRelativePaths) {
        if (normalizedText.includes(relativePath.replace(/\\/g, '/'))) {
          foundPaths.add(relativePath);
        }
      }

      // Pass 2: Handle ambiguous basename-only matches.
      for (const [basename, paths] of basenameToPaths.entries()) {
        const hasExistingMatch = paths.some(p => foundPaths.has(p));
        if (hasExistingMatch) continue;

        const basenameRegex = new RegExp(
          `\\b${basename.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\b`,
          'g',
        );

        let match;
        let hasStandaloneMatch = false;
        while ((match = basenameRegex.exec(text)) !== null) {
          if (match.index > 0) {
            const charBefore = text[match.index - 1];
            // Avoid matching a basename that is part of a larger filename
            // e.g. matching 'types.ts' inside 'domain.types.ts'
            if (/[\w.-]/.test(charBefore)) {
              continue;
            }
          }
          hasStandaloneMatch = true;
          break; // One standalone match is enough to trigger
        }

        if (hasStandaloneMatch) {
          paths.forEach(p => foundPaths.add(p));
        }
      }
      return Array.from(foundPaths);
    }


    /**
     * Extracts paths using a regex-based strategy.
     * @param text The text to search within.
     * @returns An array of found path strings, without post-processing.
     */
    function extractPathsWithRegex(text: string): string[] {
      // 1. Find all potential paths using the regex.
      const matches = Array.from(text.matchAll(PATH_REGEX), m => m[0]);

      // 2. Extract valid paths from potentially malformed matches
      const extractedPaths: string[] = [];
      for (const match of matches) {
        // If the match contains line breaks, it might contain multiple paths
        if (match.includes('\n')) {
          // Extract individual file paths from multiline strings
          const pathPattern = /[a-zA-Z0-9_./\\-]+(?:\/[a-zA-Z0-9_.-]+)*\.[a-zA-Z0-9]{1,5}(?::\d+(?::\d+)?)?/gm;
          const pathMatches = match.match(pathPattern);
          if (pathMatches) {
            extractedPaths.push(...pathMatches.map(p => p.trim()));
          }
        } else {
          extractedPaths.push(match);
        }
      }

      // 3. Clean up matches: remove trailing line/col numbers and common punctuation.
      const cleanedPaths = extractedPaths.map(p => {
        let pathStr = p;

        // Remove line/column numbers and other trailing noise.
        // Handles: :5:10, (5,10), :5, :5:, (5,10):
        pathStr = pathStr.replace(/[:(]\d+(?:[.,:]\d+)*\)?[:]?$/, '');

        // Remove query strings and fragments
        pathStr = pathStr.replace(/[?#].*$/, '');

        // Special handling for quoted paths and parentheses
        if ((pathStr.startsWith('"') && pathStr.endsWith('"')) ||
            (pathStr.startsWith("'") && pathStr.endsWith("'"))) {
          pathStr = pathStr.slice(1, -1);
        } else if (pathStr.startsWith('(') && pathStr.endsWith(')')) {
          // Remove outer parentheses from parenthesized paths
          pathStr = pathStr.slice(1, -1);
        } else {
          // For non-quoted paths, be more careful about punctuation
          pathStr = pathStr.replace(/^["'\[<{]+/, ''); // Remove leading quotes, brackets, angle brackets, curly braces
          pathStr = pathStr.replace(/["'\]>.,;}]+$/, ''); // Remove trailing quotes, brackets, angle brackets, curly braces, and punctuation
        }

        // Normalize backslashes but preserve UNC paths
        if (!pathStr.startsWith('\\\\')) {
          pathStr = pathStr.replace(/\\\\/g, '\\');
        }

        // Handle UNC paths intelligently - preserve file shares, normalize URL paths
        if (pathStr.startsWith('//') && !pathStr.startsWith('\\\\')) {
          // If it has a file extension, it's likely a file path that should be normalized
          // If it doesn't have an extension and has only 2 segments, it's likely a UNC share
          const hasExtension = /\.[a-zA-Z0-9]{1,5}$/.test(pathStr);
          const segments = pathStr.split('/').filter(s => s.length > 0);
          
          if (hasExtension || segments.length > 2) {
            // This looks like a file path, convert //server/file.txt to /server/file.txt
            pathStr = pathStr.substring(1);
          }
          // Otherwise keep as UNC share like //server/share
        }

        // Remove URL scheme and domain if present
        pathStr = pathStr.replace(/^https?:\/\/[^\/]+/, '');

        // Remove domain prefix if this looks like a URL path without scheme
        // Only remove if it starts with common TLDs that suggest it's a domain
        const commonTlds = /\.(com|org|net|edu|gov|mil|io|co|ai|dev|app|xyz)\//;
        if (pathStr.match(commonTlds)) {
          pathStr = pathStr.replace(/^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}\//, '/');
        }

        return pathStr;
      });

      // 4. Filter out commonly ignored paths (e.g., node_modules).
      const filteredPaths = cleanedPaths.filter(p => !isIgnored(p));

      // 5. Filter out version numbers and other non-path patterns
      const versionPattern = /^[a-zA-Z]?v?\d+(?:\.\d+)*$/;
      const uuidPattern = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i;
      const hashPattern = /^[a-f0-9]{7,40}$/i;
      const emailPattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
      // const urlDomainPattern = /^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/; // Only filter pure domains, not paths

    const validPaths = filteredPaths.filter(p => {
        // Filter out multi-line strings and very long strings
        if (p.includes('\n') || p.length > 200) {
          return false;
        }
        
        // Filter out function calls and method names specifically
        if (p.includes('.') && !p.includes('/') && !p.includes('\\')) {
          // This could be a function call like 'initActions.setAnalysisResults'
          // But keep actual filenames like 'file.txt'
          const parts = p.split('.');
          if (parts.length > 1) {
            const lastPart = parts[parts.length - 1];
                if (!lastPart) return false;

                // If the "extension" is mixed case, it is not a file extension.
                const isMixedCase = /[A-Z]/.test(lastPart) && /[a-z]/.test(lastPart);
                if (isMixedCase) {
                    return false;
                }

                // If it's very long, it's probably not an extension
                if (lastPart.length > 8) return false;
          }
        }
        
        // Filter out import statements and module references that appear in TypeScript errors
        if (p.startsWith('"') && p.endsWith('"')) {
          // Always filter quoted strings - they're usually import paths in error messages
          return false;
        }
        
        // Filter out relative import module references without file extensions
        if ((p.startsWith('./') || p.startsWith('../')) && !p.includes(' ')) {
          // If it doesn't have a file extension and is short, it's likely a module import
          if (!/\.[a-zA-Z0-9]{1,5}$/.test(p) && p.split('/').length <= 3) {
              return false;
            }
          }

        return !versionPattern.test(p) &&
               !uuidPattern.test(p) &&
               !hashPattern.test(p) &&
               !emailPattern.test(p) &&
               p.trim() !== '';
      });

      // 6. Fix split paths that contain parentheses
      const fixedPaths = fixSplitPaths(validPaths);
      return fixedPaths;
    }


    /**
     * Fixes paths that were incorrectly split due to parentheses in the middle.
     * @param paths Array of extracted paths that may contain split paths.
     * @returns Array of paths with split paths reassembled.
     */
    function fixSplitPaths(paths: string[]): string[] {
      const result: string[] = [];
      let i = 0;

      while (i < paths.length) {
        const current = paths[i];

        // Check if current path starts with '(' and next path ends with ')'
        if (i < paths.length - 1 &&
            current && (current.startsWith('(') || current.endsWith('(')) &&
            paths[i + 1] && paths[i + 1]?.match(/\).*\.[a-zA-Z0-9]+$/)) {
          // Combine the paths and clean up
          let combined = current + ' ' + paths[i + 1];

          // Remove leading opening parenthesis and fix the path structure
          if (combined.startsWith('(')) {
            combined = combined.substring(1);
          }
          // Replace " new).tsx" with " (new).tsx" to preserve inner parentheses
          combined = combined.replace(/ new\)\.([a-zA-Z0-9]+)$/, ' (new).$1');

          result.push(combined);
          i += 2; // Skip the next path as we've already consumed it
        } else {
          result.push(current || '');
          i++;
        }
      }

      return result;
    }


    /**
     * Extracts potential file paths from a blob of text using a configurable strategy.
     * @param text The text to search within.
     * @param opts Configuration options for extraction.
     * @returns A promise that resolves to an array of found file paths.
     */
    export async function extractPaths(
      text: string,
      opts: Options = {},
    ): Promise<string[]> {
      const {
        absolute = false,
        cwd = process.cwd(),
        unique = true,
        strategy = 'fuzzy',
      } = opts;

      let combinedPaths: string[] = [];

      if (strategy === 'regex' || strategy === 'both') {
        combinedPaths.push(...extractPathsWithRegex(text));
      }

      if (strategy === 'fuzzy' || strategy === 'both') {
        combinedPaths.push(...(await extractPathsWithFuzzy(text, cwd)));
      }

      const uniquePaths = unique ? Array.from(new Set(combinedPaths)) : combinedPaths;

      const resolvedPaths = absolute
        ? uniquePaths.map(p => path.resolve(cwd, p))
        : uniquePaths;

      return resolvedPaths;
    }


    /**
     * Filters a list of paths, keeping only the ones that exist on disk.
     * @param paths An array of file paths to check.
     * @param cwd The working directory to resolve relative paths against.
     * @returns A promise that resolves to an array of existing file paths.
     */
    export async function verifyPaths(paths: string[], cwd: string =
    process.cwd()): Promise<string[]> {
      // Concurrently check for the existence of each file.
      const checks = paths.map(async p => {
        const absolutePath = path.isAbsolute(p) ? p : path.resolve(cwd, p);
        try {
          await fs.access(absolutePath);
          return true;
        } catch {
          return false;
        }
      });
      const existenceChecks = await Promise.all(checks);

      // Filter the original paths array based on the results of the existence checks.
      const existingPaths = paths.filter((_, i) => existenceChecks[i]);

      return existingPaths;
    }
  test/unit/core.test.ts: >-
    import { describe, it, expect, beforeEach, afterEach } from 'bun:test';

    import path from 'node:path';

    import { extractPaths, verifyPaths, type Options, type Strategy } from
    '../../dist/core.js';

    import {
      loadYamlFixture,
      setupTestDirectory,
      cleanupTestDirectory,
    } from '../test.utils';


    type ExtractPathsTestCase = {
      name: string;
      options: Options;
      input: string;
      files?: { [path: string]: string };
      expected?: string[];
      expected_by_strategy?: {
        [S in Strategy]?: string[];
      };
    };


    describe('core.ts', () => {
      describe('extractPaths', async () => {
        const fixtures = await loadYamlFixture<ExtractPathsTestCase[]>('unit/core.fixtures.yaml');

        for (const { name, options, input, files, expected, expected_by_strategy } of fixtures) {
          if (expected_by_strategy) {
            describe(name, () => {
              for (const [strategy, expectedOutput] of Object.entries(
                expected_by_strategy,
              )) {
                if (!expectedOutput) continue;
                it(`with strategy: ${strategy}`, async () => {
                  let tempDir: string | undefined;
                  let cwd = options.cwd || process.cwd();
                  if (files && Object.keys(files).length > 0) {
                    tempDir = await setupTestDirectory(files);
                    cwd = tempDir;
                  }

                  const result = await extractPaths(input, {
                    ...options,
                    cwd,
                    strategy: strategy as Strategy,
                  });
                  // Sort for stable comparison
                  expect(result.sort()).toEqual(expectedOutput.sort());

                  if (tempDir) {
                    await cleanupTestDirectory(tempDir);
                  }
                });
              }
            });
          } else {
            it(name, async () => {
              let tempDir: string | undefined;
              let cwd = options.cwd || process.cwd();
              if (files && Object.keys(files).length > 0) {
                tempDir = await setupTestDirectory(files);
                cwd = tempDir;
              }

              const result = await extractPaths(input, { ...options, cwd });
              // Sort for stable comparison
              expect(result.sort()).toEqual((expected ?? []).sort());

              if (tempDir) {
                await cleanupTestDirectory(tempDir);
              }
            });
          }
        }
      });

      describe('verifyPaths', () => {
        let tempDir: string;
        const testFiles = {
          'file1.txt': 'hello',
          'dir/file2.js': 'content',
          'dir/subdir/file3.json': '{}',
        };

        beforeEach(async () => {
          tempDir = await setupTestDirectory(testFiles);
        });

        afterEach(async () => {
          await cleanupTestDirectory(tempDir);
        });

        it('should return only paths that exist on disk', async () => {
          const pathsToCheck = [
            path.join(tempDir, 'file1.txt'), // exists
            path.join(tempDir, 'dir/file2.js'), // exists
            path.join(tempDir, 'non-existent.txt'), // does not exist
            path.join(tempDir, 'dir/subdir/another.json'), // does not exist
          ];

          const expected = [
            path.join(tempDir, 'file1.txt'),
            path.join(tempDir, 'dir/file2.js'),
          ];

          const result = await verifyPaths(pathsToCheck, tempDir);
          expect(result.sort()).toEqual(expected.sort());
        });

        it('should return an empty array if no paths exist', async () => {
          const pathsToCheck = [
            path.join(tempDir, 'foo.txt'),
            path.join(tempDir, 'bar.js'),
          ];
          const result = await verifyPaths(pathsToCheck, tempDir);
          expect(result).toEqual([]);
        });

        it('should return an empty array for empty input', async () => {
          const result = await verifyPaths([], tempDir);
          expect(result).toEqual([]);
        });
      });
    });
  test/integration/engine.test.ts: |-
    import { describe, it, expect, beforeEach, afterEach } from 'bun:test';
    import { runPipeline, type PipelineOptions } from '../../dist/engine.js';
    import {
      loadYamlFixture,
      setupTestDirectory,
      cleanupTestDirectory,
    } from '../test.utils';

    type EngineTestCase = {
      name: string;
      options: PipelineOptions;
      input: string;
      files: { [path: string]: string };
      expected: string;
    };

    describe('engine.ts (Integration)', async () => {
      const fixtures = await loadYamlFixture<EngineTestCase[]>('integration/engine.fixtures.yaml');

      describe('runPipeline', () => {
        // Use a separate describe block for each test case to avoid closure issues
        fixtures.forEach(({ name, options, input, files, expected }) => {
          describe(name, () => {
            let tempDir: string;

            beforeEach(async () => {
              tempDir = await setupTestDirectory(files);
            });

            afterEach(async () => {
              await cleanupTestDirectory(tempDir);
            });

            it('should execute correctly', async () => {
              // Use the temp directory as the CWD for the pipeline
              const result = await runPipeline(input, { ...options, cwd: tempDir });

              const expectedWithCwd = expected.replaceAll('{{CWD}}', tempDir);

              // Use different comparison strategies based on format to avoid flaky tests
              if (options.format === 'list' || options.format === 'yaml') {
                // For line-based formats, sort lines to make comparison order-insensitive
                const sortLines = (s: string) =>
                  s.trim().split('\n').map(l => l.trim()).sort();
                expect(sortLines(result)).toEqual(sortLines(expectedWithCwd));
              } else {
                // For JSON, a simple trim is usually enough, as order is often preserved.
                // More complex JSON could be parsed and deep-sorted if needed.
                expect(result.trim()).toEqual(expectedWithCwd.trim());
              }
            });
          });
        });
      });
    });
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 45
